From 6b9e5be0fbc07ae3d6525bbd57c60da58d33b840 Mon Sep 17 00:00:00 2001
From: Petros Angelatos <petrosagg@gmail.com>
Date: Thu, 24 Dec 2015 14:43:17 -0800
Subject: [PATCH] implement qemu_execve() function

Introduce a new option, -execve, which will intercept all calls to
execve() and inject the intepreter to the call before passing it to the
host kernel. This has the effect of being able to emulate forking
processes without needing help from the host system using binfmt_misc or
some other method.

Currently the path to the emulator is hard-coded, it should probably be
specified in the parameter.

Signed-off-by: Petros Angelatos <petrosagg@gmail.com>
---
 linux-user/main.c    |  7 ++++
 linux-user/qemu.h    |  1 +
 linux-user/syscall.c | 97 +++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 104 insertions(+), 1 deletion(-)

diff --git a/linux-user/main.c b/linux-user/main.c
index 8acfe0fdf4..e503cf64dc 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -3837,6 +3837,11 @@ static void handle_arg_guest_base(const char *arg)
     have_guest_base = 1;
 }
 
+static void handle_arg_execve(const char *arg)
+{
+    do_qemu_execve = 1;
+}
+
 static void handle_arg_reserved_va(const char *arg)
 {
     char *p;
@@ -3922,6 +3927,8 @@ static const struct qemu_argument arg_table[] = {
      "uname",      "set qemu uname release string to 'uname'"},
     {"B",          "QEMU_GUEST_BASE",  true,  handle_arg_guest_base,
      "address",    "set guest_base address to 'address'"},
+    {"execve",     "QEMU_EXECVE",      false, handle_arg_execve,
+     "",           "continue emulating when a process calls execve"},
     {"R",          "QEMU_RESERVED_VA", true,  handle_arg_reserved_va,
      "size",       "reserve 'size' bytes for guest virtual address space"},
     {"d",          "QEMU_LOG",         true,  handle_arg_log,
diff --git a/linux-user/qemu.h b/linux-user/qemu.h
index bd90cc3799..f1659005e4 100644
--- a/linux-user/qemu.h
+++ b/linux-user/qemu.h
@@ -260,6 +260,7 @@ void mmap_fork_end(int child);
 
 /* main.c */
 extern unsigned long guest_stack_size;
+extern int do_qemu_execve;
 
 /* user access */
 
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 6c64ba63db..0f5b13910a 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -5663,6 +5663,96 @@ static target_timer_t get_timer_id(abi_long arg)
     return timerid;
 }
 
+#define BINPRM_BUF_SIZE 128
+
+int do_qemu_execve;
+
+/* qemu_execve() Must return target values and target errnos. */
+static abi_long qemu_execve(char *filename, char *argv[],
+                  char *envp[])
+{
+    char *i_arg = NULL, *i_name = NULL;
+    char **new_argp;
+    int argc, fd, ret, i, offset = 3;
+    char *cp;
+    char buf[BINPRM_BUF_SIZE];
+
+    for (argc = 0; argv[argc] != NULL; argc++);
+
+    fd = open(filename, O_RDONLY);
+    if (fd == -1)
+        return -ENOENT;
+
+    ret = read(fd, buf, BINPRM_BUF_SIZE);
+    if (ret == -1) {
+        close(fd);
+        return -ENOENT;
+    }
+
+    close(fd);
+
+    /* adapted from the kernel
+     * https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/binfmt_script.c
+     */
+    if ((buf[0] == '#') && (buf[1] == '!')) {
+        /*
+         * This section does the #! interpretation.
+         * Sorta complicated, but hopefully it will work.  -TYT
+         */
+
+        buf[BINPRM_BUF_SIZE - 1] = '\0';
+        if ((cp = strchr(buf, '\n')) == NULL)
+            cp = buf+BINPRM_BUF_SIZE-1;
+        *cp = '\0';
+        while (cp > buf) {
+            cp--;
+            if ((*cp == ' ') || (*cp == '\t'))
+                *cp = '\0';
+            else
+                break;
+        }
+        for (cp = buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
+        if (*cp == '\0')
+            return -ENOEXEC; /* No interpreter name found */
+        i_name = cp;
+        i_arg = NULL;
+        for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
+            /* nothing */ ;
+        while ((*cp == ' ') || (*cp == '\t'))
+            *cp++ = '\0';
+        if (*cp)
+            i_arg = cp;
+
+        if (i_arg)
+            offset = 5;
+        else
+            offset = 4;
+    }
+
+    new_argp = alloca((argc + offset + 1) * sizeof(void *));
+
+    // Copy the original arguments with offset
+    for (i = 0; i < argc; i++)
+        new_argp[i + offset] = argv[i];
+
+    new_argp[0] = strdup("/usr/bin/qemu-arm-static");
+    new_argp[1] = strdup("-0");
+    new_argp[offset] = filename;
+    new_argp[argc + offset] = NULL;
+
+    if (i_name) {
+        new_argp[2] = i_name;
+        new_argp[3] = i_name;
+
+        if (i_arg)
+            new_argp[4] = i_arg;
+    } else {
+        new_argp[2] = argv[0];
+    }
+
+    return get_errno(execve("/usr/bin/qemu-arm-static", new_argp, envp));
+}
+
 /* do_syscall() should always have a single exit point at the end so
    that actions, such as logging of syscall results, can be performed.
    All errnos that do_syscall() returns must be -TARGET_<errcode>. */
@@ -5913,7 +6003,12 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
 
             if (!(p = lock_user_string(arg1)))
                 goto execve_efault;
-            ret = get_errno(execve(p, argp, envp));
+
+            if (do_qemu_execve)
+                ret = get_errno(qemu_execve(p, argp, envp));
+            else
+                ret = get_errno(execve(p, argp, envp));
+
             unlock_user(p, arg1, 0);
 
             goto execve_end;
